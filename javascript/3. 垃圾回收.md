## 内存回收

> 浏览器会定时将用不到的内存清除，时间间隔因浏览器不同而不同

## 内存泄漏

> 用不到的变量，它所占内存本应该释放，但是没有释放，造成的内存损耗


## 内存回收的几种方式

- 标记清除
- 引用计数

### 标记清除

> 垃圾回收器会在刚开始将内存中的变量都加上标记，然后他会去掉环境中的变量以及被环境中的变量引用的变量的标记，而在此之后再次被加上标记的变量就是下次会被回收的变量，原因是环境中的变量无法访问到这些变量了。

需要注意：

- 使用标记清除模式，只有在全局变量**直接引用**和**间接引用**的情况下，内存无法释放，其他的都可以释放。所以在编写程序的时候如果涉及到全局变量需要慎重思考。

- 由于垃圾回收器回收是有时间间隔的，并且web应用分配的系统内存很少，所以要养成不用的变量主动释放，设置变量为null。

- **解除引用**：将不用的变量设置为null，最主要针对的是全局变量，全局对象的属性，局部变量会在离开作用域时主动解除引用。


闭包引用不一定不能释放：
- 如果闭包中匿名函数赋值给了全局变量，那么所引用的外部函数变量确实无法释放
- 如果闭包中匿名函数赋值实在匿名函数中执行的，那么外部变量是可以释放的。

```
function func(count){
  return function(){
    let a = count;
  }
}

// 外部函数的count无法释放
let var_func = func(); 

(function(){
  function func(count){
    return function(){
      let a = count;
    }
  }

  // 外部函数的count可以释放
  let var_func = func(); 
}())

```


### 引用计数

> 当声明了一个变量或者把一个引用类型的变量赋值给该变量时，引用数值就会加1，如果同一个值，又被另一个变量引用，那么引用值再加 1，如果引用此值的变量引用了其他的变量，那么引用值减 1，当引用值为零时，说明环境中没有引用他的变量了，当下次垃圾回收器回收垃圾时，引用次数为零的变量就会被回收。

**缺点**：引用计数，如果遇到循环引用就无能为力了。

```
function func(){
  var obj1 = new Object();
  var obj2 = new Object();

  obj1.name = obj2;
  obj2.age = obj1;
}
```
上面两个变量互相引用，引用次数不可能为零，那么使用**引用计数**模式永远也不可能清除这两个变量，**标记清除**模式，由于这两变量都不在作用域中，很好被清除。